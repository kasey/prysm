package sszgen

type PackageIndex struct {
	sourcePackage string
	index map[string]PackageParser
	structCache map[[2]string]*ParseNode
}

func NewPackageIndex() *PackageIndex {
	pi := &PackageIndex{
		index: make(map[string]PackageParser),
		structCache: make(map[[2]string]*ParseNode),
	}
	return pi
}

func (pi *PackageIndex) getParser(packagePath string) (PackageParser, error) {
	pkg, ok := pi.index[packagePath]
	if ok {
		return pkg, nil
	}
	pkg, err := NewPackageParser(packagePath)
	if err == nil {
		pi.index[packagePath] = pkg
	}
	return pkg, err
}

func (pi *PackageIndex) DeclarationRefs(packagePath string) ([]*DeclarationRef, error) {
	pkg, err := pi.getParser(packagePath)
	if err != nil {
		return nil, err
	}
	refs := make([]*DeclarationRef, 0)
	for _, p := range pkg.AllParseNodes() {
		refs = append(refs, p.DeclarationRef())
	}
	return refs, nil
}

// go does not require the package path to match the package name
// the package of the methods generated by this tool must match the
// package name used by other files in the package, so we need to
// expose that value through the parser/index.
func (pi *PackageIndex) GetPackageName(packagePath string) (string, error) {
	pkg, err := pi.getParser(packagePath)
	if err != nil {
		return "", err
	}
	return pkg.PackageName()
}

func (pi *PackageIndex) GetType(packagePath, typeName string) (*ParseNode, error) {
	cached, ok := pi.structCache[[2]string{packagePath,typeName}]
	if ok {
		return cached, nil
	}
	pkg, err := pi.getParser(packagePath)
	if err != nil {
		return nil, err
	}
	ts, err := pkg.GetType(typeName)
	if err != nil {
		return nil, err
	}
	pi.structCache[[2]string{packagePath,typeName}]	= ts
	return ts, nil
}
